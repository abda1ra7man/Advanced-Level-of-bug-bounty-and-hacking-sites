# اختبار الـ API

# Overview

### اختبار الـ API

الـ APIs (واجهات برمجة التطبيقات) بتخلّي الأنظمة والتطبيقات تتواصل مع بعض وتشارك البيانات. اختبار الـ API مهم جدًا لأن أي ثغرات فيه ممكن تدمّر أمان وخصوصية الموقع.

كل المواقع الديناميكية بتعتمد على الـ APIs، وعشان كده، أي ثغرات تقليدية زي SQL Injection ممكن تبقى جزء من اختبار الـ API. في الموضوع ده، هنتعلم إزاي نختبر الـ APIs اللي مش مستخدمة بالكامل في الواجهة الأمامية للموقع، مع التركيز على RESTful و JSON APIs، وكمان هنشوف إزاي نختبر ثغرات زي Server-side Parameter Pollution اللي ممكن تأثر على الـ APIs الداخلية.

علشان نوضّح العلاقة بين اختبار الـ API واختبار أمان المواقع بشكل عام، هنقدّم مقارنة بين المواضيع اللي هنشرحها وبين قائمة OWASP API Security Top 10 لسنة 2023.

# API recon

### استكشاف الـ API

قبل ما تبدأ في اختبار الـ API، لازم تجمع أكبر قدر ممكن من المعلومات عنه علشان تقدر تحدد نقاط الضعف اللي ممكن تستغلها.

#### تحديد الـ API Endpoints

نقاط النهاية (Endpoints) هي الأماكن اللي بيستقبل فيها الـ API الطلبات الخاصة بالموارد على السيرفر. مثال على طلب GET:
```
GET /api/books HTTP/1.1
Host: example.com
```

الـ Endpoint هنا هو `/api/books`، واللي بيستدعي قائمة الكتب المتاحة في المكتبة. مثال تاني:
```
GET /api/books/mystery
```

ده هيستدعي قائمة الكتب الغامضة فقط.

#### التفاعل مع الـ API

بمجرد ما تحدد الـ Endpoints، لازم تفهم إزاي تتعامل معاها وتبعت طلبات صحيحة للاختبار. لازم تعرف:
- نوع البيانات اللي الـ API بيعالجها، سواء كانت إلزامية أو اختيارية.
- أنواع الطلبات اللي بيقبلها الـ API زي GET, POST, PUT, DELETE.
- حدود الاستخدام (Rate Limits) وأنظمة المصادقة (Authentication).

# API documentation

### مستندات الـ API

الـ APIs بيكون ليها مستندات بتوضح للمطورين إزاي يستخدموها ويتكاملوا معاها. المستندات دي نوعين:
- **مقروءة للبشر**: بتحتوي على شرح تفصيلي، أمثلة، وسيناريوهات استخدام.
- **مقروءة آليًا**: بتكون بتنسيقات زي JSON أو XML، وبتستخدم في الأتمتة والاختبار.

في بعض الأحيان، مستندات الـ API بتكون متاحة للعامة، وده بيكون مفيد جدًا عند البحث عن نقاط الضعف.

## Discovering API documentation

حتى لو مستندات الـ API مش متاحة للعامة، ممكن تلاقيها من خلال تحليل التطبيقات اللي بتستخدمه. 

#### طرق البحث عن المستندات:
- استخدام **Burp Scanner** لفحص الـ API واكتشاف أي مستندات غير معلنة.
- تصفح التطبيقات يدويًا باستخدام **Burp's browser**.
- البحث عن مسارات قد تحتوي على المستندات، زي:
 ```url
/api
/swagger/index.html
/openapi.json
  ```


لو لقيت مسار مرتبط بمصدر معين زي `/api/swagger/v1/users/123`، جرب مسارات مشابهة:
```
/api/swagger/v1
/api/swagger
/api
```

كمان تقدر تستخدم قوائم المسارات الشائعة مع **Intruder** لاكتشاف مستندات إضافية.

## Using machine-readable API documentation

تقدر تحلل المستندات الآلية باستخدام أدوات متخصصة:
- **Burp Scanner** لفحص مستندات OpenAPI.
- **OpenAPI Parser BApp** لتحليل وتدقيق المستندات.
- **Postman أو SoapUI** لاختبار الـ API مباشرة باستخدام المستندات المتاحة.

# Identifying API endpoints

## Interacting with API endpoints

### التفاعل مع الـ API Endpoints

بعد ما تحدد الـ API Endpoints، لازم تتفاعل معاها باستخدام أدوات زي **Burp Repeater** و **Burp Intruder**. الأدوات دي بتساعدك في تحليل استجابة الـ API وكشف نقاط ضعف إضافية. على سبيل المثال، ممكن تختبر استجابة الـ API عند تغيير **طريقة الطلب (HTTP Method)** أو **نوع البيانات (Media Type)**.

### تحليل استجابات الـ API

وأنت بتتعامل مع الـ API، راقب رسائل الخطأ والردود بعناية، لأن أحيانًا ممكن تحتوي على معلومات مفيدة تساعدك في تكوين طلبات HTTP صحيحة.

### تحديد طرق HTTP المدعومة

طريقة HTTP بتحدد الإجراء اللي هيتم على المورد. بعض الطرق الشائعة:

- **GET** - لاسترجاع البيانات.
- **PATCH** - لتعديل جزء من البيانات.
- **OPTIONS** - لمعرفة الطرق المدعومة من الـ API.

بعض الـ API Endpoints بتدعم أكتر من طريقة، وده معناه إنك لازم تختبر كل الطرق المحتملة علشان تكشف أي وظائف إضافية.

#### مثال على API Endpoints متعددة الوظائف:
```
GET /api/tasks - لاسترجاع قائمة المهام.
POST /api/tasks - لإنشاء مهمة جديدة.
DELETE /api/tasks/1 - لحذف مهمة.
```

ممكن تستخدم **Burp Intruder** لتجربة كل طرق HTTP المتاحة تلقائيًا.

### ملاحظة

لما تجرب طرق HTTP مختلفة، استهدف الكائنات ذات الأولوية المنخفضة علشان تتجنب أي تأثير غير مقصود، زي حذف بيانات مهمة أو إنشاء سجلات غير ضرورية.

### تحديد أنواع المحتوى المدعومة

بعض الـ API Endpoints بتتوقع بيانات بصيغة معينة، وده بيأثر على استجابتها. تغيير نوع المحتوى ممكن يساعدك في:
- **إثارة أخطاء تكشف معلومات مفيدة.**
- **تجاوز دفاعات ضعيفة.**
- **استغلال اختلافات في معالجة البيانات.**

على سبيل المثال، ممكن يكون الـ API آمن عند التعامل مع **JSON** لكنه ضعيف أمام **XML Injection**.

#### كيفية تغيير نوع المحتوى:
- عدّل الهيدر `Content-Type`.
- أعد تنسيق جسم الطلب حسب النوع الجديد.
- استخدم **Content Type Converter BApp** لتحويل البيانات بين **XML و JSON** تلقائيًا.


# Finding hidden parameters

### البحث عن البارامترات المخفية

وأنت بتعمل استكشاف للـ API، ممكن تلاقي **بارامترات غير موثقة** لكن مدعومة من الـ API. البارامترات دي ممكن تسمح لك بتغيير سلوك التطبيق بطرق غير متوقعة.

#### أدوات لاكتشاف البارامترات المخفية:

- **Burp Intruder**: أداة بتساعدك في اكتشاف البارامترات المخفية تلقائيًا باستخدام **قائمة كلمات شائعة** لاستبدال أو إضافة بارامترات جديدة. لازم كمان تضيف أسماء مرتبطة بالتطبيق بناءً على استكشافك الأولي.
- **Param Miner BApp**: بتقدر تخمن لحد **65,536** اسم بارامتر في كل طلب، وكمان بتستخدم معلومات من نطاق البحث علشان تخمن الأسماء الأكثر احتمالًا.
- **Content Discovery Tool**: بتساعدك في اكتشاف المحتوى المخفي اللي مش مرتبط بروابط واضحة، وده ممكن يشمل **بارامترات غير مرئية** في الواجهة العادية.

## Mass assignment vulnerabilities

### ثغرات التخصيص الجماعي (Mass Assignment)

التخصيص الجماعي (المعروف كمان باسم **Auto-binding**) ممكن يتسبب في إنشاء **بارامترات مخفية** بدون قصد. المشكلة بتحصل لما الإطارات البرمجية تربط المعاملات الموجودة في الطلب **مباشرة** مع الكائنات الداخلية في التطبيق.

بسبب ده، التطبيق ممكن يدعم **بارامترات غير مقصودة** المطور أصلاً ما كانش ناوي يعالجها، وده ممكن يؤدي لاستغلالات أمنية خطيرة.

## Identifying hidden parameters

بما إن التخصيص الجماعي (Mass Assignment) بيعمل على إنشاء بارامترات من الحقول الداخلية للكائنات، فممكن تلاقي **بارامترات مخفية** عن طريق فحص البيانات اللي بيرجعها الـ API يدويًا.

#### مثال:

لو فيه طلب `PATCH /api/users/` بيتيح للمستخدمين تعديل اسم المستخدم والبريد الإلكتروني، وبيحتوي على البيانات دي:
```
{
    "username": "wiener",
    "email": "wiener@example.com"
}
```

لكن لو أرسلت طلب `GET /api/users/123`، ورجع البيانات دي:
```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "false"
}
```

ده معناه إن البارامترات **id** و **isAdmin** ممكن تكون مرتبطة داخليًا بالكائن المستخدم، حتى لو مش ظاهرة في التوثيق.

### ثغرات التخصيص الجماعي (Mass Assignment)

التخصيص الجماعي (المعروف كمان باسم **Auto-binding**) ممكن يتسبب في إنشاء **بارامترات مخفية** بدون قصد. المشكلة بتحصل لما الإطارات البرمجية تربط المعاملات الموجودة في الطلب **مباشرة** مع الكائنات الداخلية في التطبيق.

بسبب ده، التطبيق ممكن يدعم **بارامترات غير مقصودة** المطور أصلاً ما كانش ناوي يعالجها، وده ممكن يؤدي لاستغلالات أمنية خطيرة.

## Testing mass assignment vulnerabilities

#### اختبار ثغرات التخصيص الجماعي

لاختبار إذا كان ممكن تعديل قيمة بارامتر **isAdmin**، جرب تضيفه في طلب `PATCH`:
```
{
    "username": "wiener",
    "email": "wiener@example.com",
    "isAdmin": false
}
```

جرب كمان تبعت طلب `PATCH` بقيمة غير صحيحة للـ **isAdmin**:
```
{
    "username": "wiener",
    "email": "wiener@example.com",
    "isAdmin": "foo"
}
```

لو التطبيق استجاب بشكل مختلف، ده ممكن يكون دليل على إن القيمة غير الصحيحة بتأثر على منطق الاستعلام، بينما القيمة الصحيحة لا. وده ممكن يعني إن المستخدم يقدر يغيّر القيمة بنجاح.

جرب بعد كده تبعت طلب `PATCH` مع تعيين **isAdmin** إلى `true` لمحاولة استغلال الثغرة:
```
{
    "username": "wiener",
    "email": "wiener@example.com",
    "isAdmin": true
}
```

لو التطبيق بيربط القيمة المدخلة مباشرةً مع كائن المستخدم بدون **تحقق كافٍ**، المستخدم `wiener` ممكن يحصل على صلاحيات **admin** بالخطأ. للتحقق من ده، حاول تسجيل الدخول بالمستخدم `wiener` وشوف إذا كنت تقدر توصل لوظائف الـ admin.


# Preventing vulnerabilities in APIs

### تأمين الـ APIs ومنع الثغرات

عند تصميم الـ API، لازم يكون الأمان من الأولويات الأساسية. علشان تحمي الـ API من الثغرات، اتبع الخطوات دي:

- **حماية المستندات**: لو الـ API مش مفتوح للعامة، لازم تأمن المستندات الخاصة بيه.
- **تحديث المستندات**: تأكد إن الوثائق دايمًا محدثة علشان المختبرين الشرعيين يكون عندهم رؤية كاملة لنقاط الضعف المحتملة.
- **استخدام قائمة بيضاء للطرق المسموحة**: يعني تحدد مسبقًا أي طرق HTTP مسموح بيها.
- **التحقق من نوع المحتوى**: لازم تتأكد إن البيانات اللي بيتم إرسالها واستقبالها متوافقة مع النوع المتوقع.
- **استخدام رسائل خطأ عامة**: علشان متديش للمهاجم أي معلومات إضافية عن النظام.
- **تطبيق الحماية على جميع الإصدارات**: مش بس الإصدار الحالي، لكن كمان الإصدارات القديمة اللي لسه شغالة.

#### منع ثغرات التخصيص الجماعي (Mass Assignment)

- استخدم **قائمة بيضاء** للبارامترات اللي المستخدم يقدر يعدلها.
- استخدم **قائمة سوداء** لمنع تعديل البارامترات الحساسة زي `isAdmin` أو `userRole`.
- تحقق من البيانات اللي بيتم استقبالها وتأكد إنها متوافقة مع المتطلبات الأمنية للتطبيق.

---
# Server-side Parameter Pollution

بعض الأنظمة بتحتوي على **APIs داخلية** مش متاحة مباشرة من الإنترنت. **تلوث البارامترات على السيرفر** بيحصل لما الموقع يستخدم مدخلات المستخدم في طلب موجّه لـ API داخلي **بدون تشفير مناسب**. وده ممكن يسمح للمهاجم إنه:

- **يتجاوز البارامترات الموجودة.**
- **يعدل سلوك التطبيق بشكل غير متوقع.**
- **يصل إلى بيانات غير مصرح له بالوصول إليها.**

### طرق اختبار تلوث البارامترات

أي مدخل للمستخدم ممكن يكون عرضة للهجوم، سواء كان:
- **بارامترات في الـ Query String**.
- **حقول داخل الـ Form.**
- **Headers في الطلبات.**
- **بارامترات في مسار الـ URL.**

### ملاحظة

الثغرة دي أحيانًا بيتم تسميتها **HTTP Parameter Pollution**، لكنها بتُستخدم برضه كطريقة لتجاوز جدران الحماية WAF، علشان كده هنا هنستخدم مصطلح **Server-side Parameter Pollution** فقط عشان نتجنب اللبس.

كمان، رغم تشابه الاسم، الفئة دي من الثغرات **مختلفة تمامًا** عن **Server-side Prototype Pollution**.

---
## Testing for Server-side Parameter Pollution in the Query String

### اختبار تلوث البارامترات على السيرفر في الـ Query String

لاختبار التلوث في الـ Query String، قم بإدخال رموز تحليل مثل `#`, `&`, و `=` في المدخلات، وراقب استجابة التطبيق.

### مثال على تطبيق ضعيف:
عند البحث عن مستخدم معين، يرسل المتصفح الطلب التالي:
```
GET /userSearch?name=peter&back=/home
```

يقوم السيرفر بتنفيذ طلب داخلي للـ API:
```
GET /users/search?name=peter&publicProfile=true
```

### تقصير سلاسل الاستعلام (Truncating Query Strings)

يمكنك استخدام الحرف `#` المشفر (`%23`) لمحاولة تقصير الطلب الداخلي.

#### مثال:
```
GET /userSearch?name=peter%23foo&back=/home
```

يتم تحويله إلى:
```
GET /users/search?name=peter#foo&publicProfile=true
```

### حقن بارامترات غير صالحة (Injecting Invalid Parameters)

يمكنك استخدام الرمز `&` المشفر (`%26`) لإضافة بارامتر جديد إلى الطلب الداخلي.

#### مثال:
```
GET /userSearch?name=peter%26foo=xyz&back=/home
```

يتم تحويله إلى:
```
GET /users/search?name=peter&foo=xyz&publicProfile=true
```

### حقن بارامترات صالحة (Injecting Valid Parameters)

إذا تمكنت من تعديل الـ Query String، يمكنك محاولة إضافة بارامتر صالح إلى الطلب الداخلي.

#### مثال:
```
GET /userSearch?name=peter%26email=foo&back=/home
```

يتم تحويله إلى:
```
GET /users/search?name=peter&email=foo&publicProfile=true
```

### تجاوز القيم الأصلية للبارامترات (Overriding Existing Parameters)

لاختبار إمكانية التلاعب بالقيم الأصلية، قم بإدخال نفس البارامتر مرتين.

#### مثال:
```
GET /userSearch?name=peter%26name=carlos&back=/home
```

يتم تحويله إلى:
```
GET /users/search?name=peter&name=carlos&publicProfile=true
```

### التأثير حسب بيئة التطبيق:

- **PHP**: يأخذ آخر قيمة (`carlos`).
- **ASP.NET**: يدمج القيم (`peter,carlos`).
- **Node.js/Express**: يأخذ أول قيمة (`peter`).

إذا تمكنت من تجاوز القيمة الأصلية، يمكنك محاولة تسجيل الدخول كـ **Administrator** بإضافة `name=administrator` إلى الطلب.

---
## Testing for Server-side Parameter Pollution in REST Paths

### اختبار تلوث البارامترات في مسارات REST

بعض الـ APIs من نوع RESTful بتعتمد على **تمرير المعاملات داخل المسار (URL Path)** بدلًا من استخدام **Query String**. مثال على ذلك:
```
/api/users/123
```

### تحليل المسار:
- `/api` هو **المسار الرئيسي للـ API**.
- `/users` هو **المورد** (في الحالة دي المستخدمين).
- `/123` هو **المعرف الخاص بالمستخدم**.

### اختبار الثغرة:

لو التطبيق بيسمح بتعديل ملفات المستخدمين باستخدام أسمائهم، ممكن يرسل المتصفح طلب زي ده:
```
GET /edit_profile.php?name=peter
```

وده هيتم تحويله داخليًا إلى:
```
GET /api/private/users/peter
```

### استغلال الثغرة عبر Path Traversal

المهاجم ممكن يجرب **التلاعب في المسار** باستخدام **Path Traversal Sequences**.

#### مثال:
```
GET /edit_profile.php?name=peter%2f..%2fadmin
```

الطلب الداخلي الناتج:
```
GET /api/private/users/peter/../admin
```

### تأثير الثغرة:

لو الـ API الداخلي بيقوم **بتنظيم المسارات وإعادة تفسيرها (Path Normalization)**، المسار الجديد ممكن يتحول إلى:
```
GET /api/private/users/admin
```
وده ممكن يسمح للمهاجم **بالوصول إلى بيانات حساب آخر** أو **تعديل معلومات لا يملك صلاحيات عليها**.

---
## Testing for Server-side Parameter Pollution in Structured Data Formats

### اختبار تلوث البارامترات في تنسيقات البيانات المهيكلة

المهاجم ممكن يستغل ثغرات في **معالجة البيانات المهيكلة** مثل **JSON أو XML** من قبل السيرفر. لاختبار هذه الثغرة، قم بحقن بيانات غير متوقعة في مدخلات المستخدم وراقب استجابة السيرفر.

### مثال على استغلال الثغرة

#### سيناريو:

التطبيق يسمح للمستخدمين بتعديل ملفاتهم الشخصية عبر API داخلي. عند تعديل الاسم، يتم إرسال الطلب التالي:
```
POST /myaccount
name=peter
```

يتم تحويله إلى طلب داخلي على السيرفر:
```
PATCH /users/7312/update
{"name":"peter"}
```

#### محاولة استغلال الثغرة

المهاجم قد يحاول إدخال بارامتر إضافي غير متوقع:
```
POST /myaccount
name=peter","access_level":"administrator
```

إذا كان التطبيق لا يقوم بالتحقق من صحة المدخلات، يتحول الطلب إلى:
```
PATCH /users/7312/update
{"name":"peter","access_level":"administrator"}
```

مما قد يؤدي إلى **ترقية المستخدم `peter` إلى صلاحيات المسؤول (Administrator)**.

### استغلال الثغرة عند استخدام JSON

إذا كان التطبيق يعتمد على JSON، قد يحاول المهاجم حقن القيم بالطريقة التالية:
```
POST /myaccount
{"name": "peter","access_level":"administrator"}
```

يتم معالجته كالتالي:
```
PATCH /users/7312/update
{"name":"peter","access_level":"administrator"}
```

وهذا قد يمنح المستخدم صلاحيات إضافية غير مصرح بها.

### استغلال الثغرة في استجابات الـ API

هذه الثغرة قد تحدث أيضًا عند **تخزين المدخلات في قاعدة البيانات ثم إرسالها في استجابة JSON** من الـ API الخلفي **بدون تشفير مناسب**.

### ملاحظة

رغم أن الأمثلة هنا تعتمد على **JSON**، يمكن أن يحدث تلوث البارامترات في أي **تنسيق بيانات مهيكل** مثل **XML**. لمزيد من التفاصيل حول استغلال هذه الثغرة في XML، راجع **هجمات XInclude في ثغرات XXE**.

---
## Testing with Automated Tools

### استخدام الأدوات التلقائية لاختبار تلوث البارامترات على السيرفر

أدوات مثل **Burp Suite** بتوفر تقنيات تلقائية لاكتشاف **ثغرات تلوث البارامترات على السيرفر**.

### Burp Scanner

- يقوم بالكشف التلقائي عن أي **تحولات مشبوهة للمدخلات** أثناء عملية التدقيق.
- عندما يتلقى التطبيق مدخلات المستخدم ويعيد معالجتها بشكل غير متوقع، يمكن أن يشير ذلك إلى ثغرة محتملة.
- هذا السلوك لا يعني دائمًا وجود ثغرة، لذلك يجب تنفيذ **اختبارات يدوية** للتأكد من وجود الاستغلال.

🔍 **للمزيد من المعلومات:** راجع تعريف مشكلة **Suspicious input transformation** في وثائق Burp.

### Backslash Powered Scanner BApp

- هذه الأداة تُستخدم للكشف عن **ثغرات الحقن على السيرفر**.
- تصنّف المدخلات إلى: **مملة (Boring)، مثيرة للاهتمام (Interesting)، أو قابلة للاستغلال (Vulnerable)**.
- بعد تحديد المدخلات المثيرة للاهتمام، يجب اختبارها يدويًا لمعرفة إمكانية استغلالها.

🔍 **للمزيد من المعلومات:** راجع **Backslash Powered Scanning: hunting unknown vulnerability classes**.

---

## Preventing Server-side Parameter Pollution

### كيفية منع تلوث البارامترات على السيرفر

لضمان الحماية من هذه الثغرة، يجب اتباع الخطوات التالية:

✔ **استخدام قائمة بيضاء (Allowlist):** حدد مسبقًا **الرموز المسموحة** في المدخلات وتجاهل غيرها.
✔ **تشفير المدخلات:** تأكد من أن جميع بيانات المستخدم يتم **تشفيرها** قبل إرسالها إلى الطلبات الداخلية.
✔ **التحقق من البيانات:** تأكد من أن جميع المدخلات تتبع **البنية والتنسيق المتوقع** قبل معالجتها.

🛡️ **تطبيق هذه الإجراءات يقلل من فرص استغلال ثغرات تلوث البارامترات على السيرفر.**

---
# Web Security Academy Alignment with the OWASP Top 10 API Vulnerabilities

مؤسسة **OWASP** بتصدر بشكل دوري قائمة بأهم المخاطر الأمنية المتعلقة بـ **APIs**. رغم إن بعض المخاطر بيكون ليها أسماء مختلفة في سياق **APIs**، إلا إنها بتتوافق مع مواضيع الأمن السيبراني اللي بيتم تدريسها في **Web Security Academy**.

### تطابق المخاطر بين OWASP API Top 10 و Web Security Academy:

| **المخاطرة**                                      | **الموضوعات ذات الصلة في Web Security Academy** |
|-------------------------------------------------|------------------------------------------------|
| **Broken object level authorization**         | التحكم في الصلاحيات وتصعيد الامتيازات |
| **Broken authentication**                     | ثغرات المصادقة، هجمات OAuth 2.0، وهجمات JWT |
| **Broken object property level authorization** | ثغرات التخصيص الجماعي (Mass Assignment) |
| **Unrestricted resource consumption**         | سباقات الشروط (Race Conditions) وثغرات رفع الملفات |
| **Broken function level authorization**       | التحكم في الصلاحيات وتصعيد الامتيازات |
| **Unrestricted access to sensitive business flows** | ثغرات منطق الأعمال |
| **Server-side request forgery (SSRF)**        | هجمات SSRF |
| **Security misconfiguration**                 | ثغرات CORS، كشف المعلومات، وهجمات HTTP Host header، وتهريب طلبات HTTP |
| **Improper inventory management**             | اختبار الـ APIs |
| **Unsafe consumption of APIs**                | اختبار الـ APIs |

📌 **للمزيد من المعلومات** عن قائمة **OWASP API Top 10 - 2023**، يمكنك زيارة الموقع الرسمي لـ **OWASP**.

